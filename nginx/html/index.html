<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Pineapple Index</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{--bg:#fbfdff;--card:#fff;--muted:#6b7280;--accent:#2563eb}
    *{box-sizing:border-box}
    body{font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);margin:20px;color:#0f172a}
    h1{font-size:1.4rem;margin:0 0 6px 0;display:flex;align-items:baseline;gap:8px}
    .header-count{font-size:0.9rem;color:var(--muted);font-weight:500}
    .container{max-width:1200px;margin:0 auto;padding:0 12px}
    .controls{display:flex;flex-direction:column;gap:8px;align-items:stretch;margin-bottom:12px;position:relative}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .controls-row--actions{justify-content:flex-end}
    input,select,button{padding:8px 10px;border:1px solid #e6e6e6;border-radius:10px;background:var(--card)}
    button{cursor:pointer}
    .btn{border:0;padding:8px 12px;border-radius:10px;background:#eef2ff;color:var(--accent);font-weight:600}
    .btn:hover{filter:brightness(.98);box-shadow:0 4px 14px rgba(37,99,235,0.12)}
    .btn-ghost{background:transparent;border:1px solid #e6e6e6;color:inherit}
    .card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 1px 2px rgba(15,23,42,0.04)}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:10px;border-bottom:1px solid #f1f5f9;text-align:left}
    th{font-weight:600;color:#0f172a;white-space:nowrap}
    tr:hover{background:#f8fafc}
    .muted{color:var(--muted);font-size:0.9em}
    .badge{background:#eef2ff;color:var(--accent);padding:4px 8px;border-radius:999px;font-size:0.85em}
    .row-actions{display:flex;gap:8px;align-items:center}
    .spinner{width:18px;height:18px;border:3px solid #e6eefc;border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;display:inline-block}
    @keyframes spin{to{transform:rotate(360deg)}}
    @media (max-width:900px){table{font-size:13px} .controls{gap:6px}}
    @media (max-width:800px){
      .controls{flex-direction:column;align-items:stretch}
      .controls > *{width:100%}
      .controls label{display:flex;justify-content:space-between;align-items:center}
    }
    .table-wrap{overflow:auto}
    th.sticky{position:sticky;top:0;background:var(--card);z-index:2}
    .banned{color:#b91c1c;text-decoration:line-through}
    .not-found{color:#6b7280;font-style:italic}
    /* column helper classes */
    .col-name,.col-title,.col-mentions,.col-subscribers,.col-active_users,.col-first_mentioned,.col-last_checked,.col-description{}
  </style>
</head>
<body>
  <h1><a href="/" style="color:inherit;text-decoration:none">Pineapple Index</a><span id="headerSubCount" class="header-count">- 0 Subreddits found</span></h1>
  <p class="muted" style="margin-top:6px">This website does not save site data on your device.<br>
    A tribute to <a href="https://www.reddit.com/user/WeirdPineapple" target="_blank" rel="noopener noreferrer">/u/WeirdPineapple</a> — thank you for your contributions!</p>

      <div class="container">
        <div class="controls card">
          <div class="controls-row">
            <div style="position:relative;flex:1;min-width:180px">
              <input id="q" maxlength="200" placeholder="Search name, title or description" style="width:100%;padding-right:34px;box-sizing:border-box" />
              <button id="clearQuery" title="Clear search" style="position:absolute;right:8px;top:50%;transform:translateY(-50%);border:0;background:transparent;cursor:pointer;font-size:14px;display:none;color:var(--muted)">✕</button>
            </div>
            <button id="reload" class="btn btn-ghost" style="margin-left:8px">Refresh</button>
            <button id="filterBtn" class="btn btn-ghost" style="margin-left:8px">Filters ▾</button>
          </div>
          <div class="controls-row controls-row--actions">
            <label style="margin-right:12px">Open link to
              <select id="listing" style="margin-left:6px">
                <option value="hot" selected>Hot</option>
                <option value="top">Top</option>
                <option value="best">Best</option>
                <option value="new">New</option>
                <option value="rising">Rising</option>
              </select>
            </label>
            <div style="margin-right:auto" class="muted" id="loading"></div>
            <button id="sortDir" class="btn">Sort: Desc</button>
            <button id="resetFilters" class="btn btn-ghost">Reset filters</button>
          </div>
        </div>
        <!-- Filter popout: positioned relative to .controls (absolute placement) -->
        <div id="filterPop" style="display:none;position:absolute;z-index:60;min-width:260px;right:12px;top:64px;padding:10px;border-radius:10px;background:var(--card);box-shadow:0 8px 30px rgba(2,6,23,0.08)">
          <div style="display:flex;flex-direction:column;gap:8px">
            <label style="display:flex;justify-content:space-between;align-items:center">Min mentions <input id="minMentions" type="number" placeholder="0" min="0" step="1" style="width:110px"/></label>
            <label style="display:flex;justify-content:space-between;align-items:center">Max mentions <input id="maxMentions" type="number" placeholder="any" min="1" step="1" style="width:110px"/></label>
            <label style="display:flex;justify-content:space-between;align-items:center">Min subscribers <input id="minSubscribers" type="number" placeholder="0" min="0" step="1" style="width:110px"/></label>
            <label style="display:flex;justify-content:space-between;align-items:center">Max subscribers <input id="maxSubscribers" type="number" placeholder="any" min="0" step="1" style="width:110px"/></label>
            <label style="display:flex;justify-content:space-between;align-items:center"><input id="showAvailable" type="checkbox" checked/> Show available</label>
            <label style="display:flex;justify-content:space-between;align-items:center"><input id="showBanned" type="checkbox"/> Show unavailable</label>
            <label style="display:flex;justify-content:space-between;align-items:center"><input id="showNSFW" type="checkbox" checked/> Show NSFW</label>
            <label style="display:flex;justify-content:space-between;align-items:center"><input id="showNonNSFW" type="checkbox"/> Show non-NSFW</label>
            <div style="display:flex;justify-content:space-between;margin-top:6px">
              <button id="clearFilters" class="btn btn-ghost">Clear</button>
              <button id="showAll" class="btn btn-ghost">Show all</button>
              <button id="closeFilterPop" class="btn">Close</button>
            </div>
          </div>
        </div>
      </div>

      <div class="muted" id="count"></div>
      <div class="table-wrap card" style="padding:0;margin-top:12px">
      <table id="tbl">
    <thead>
      <tr>
                <th class="sticky col-name" data-sort="display_name_prefixed">Display Name</th>
                <th class="sticky col-title" data-sort="title">Title</th>
                <th class="sticky col-mentions" data-sort="mentions">Mentions</th>
                <th class="sticky col-subscribers" data-sort="subscribers">Subscribers</th>
                <th class="sticky col-first_mentioned" data-sort="first_mentioned">First mentioned</th>
                <th class="sticky col-description" data-sort="description">Description</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  </div>
    </div>
    

  <script>
    let data = [];
    let totalCount = 0;
    let currentSort = 'mentions';
    let currentSortDir = 'desc'; // 'asc' or 'desc'

    function updateColumnVisibility(list){
      try{
        // Always show columns. Do not hide table columns even if no rows have data
        // for that column; this preserves stable table layout for users.
        const cols = ['title','subscribers','description','first_mentioned','last_checked'];
        cols.forEach(col => {
          document.querySelectorAll('.col-' + col).forEach(el => el.style.display = '');
          const th = document.querySelector('th.col-' + col);
          if(th) th.style.display = '';
        });
      }catch(e){ console.warn('updateColumnVisibility failed', e); }
    }

    // Decode HTML entities in titles so escaped codes like &amp; display as &.
    function decodeHtmlEntities(str){
      if(str === null || str === undefined) return '';
      const d = document.createElement('div');
      // Assign to innerHTML so entities are parsed, then read textContent.
      d.innerHTML = String(str);
      return d.textContent || d.innerText || '';
    }

    async function loadAll(){
      document.getElementById('count').textContent = 'Loading...';
      // indicate loading in the small status area as plain text
      document.getElementById('loading').textContent = 'Loading...';
      try{
        data = [];
        let page = 1;
        const per = 500; // API cap; iterate pages until has_more false
        for(;;){
          const res = await fetch(`/subreddits?page=${page}&per_page=${per}&sort=${encodeURIComponent(currentSort)}`);
          if(!res.ok) throw new Error('HTTP '+res.status);
          const json = await res.json();
          const items = json.items || [];
          data = data.concat(items);
          totalCount = json.total || 0;
          document.getElementById('count').textContent = `${totalCount} in database — ${data.length} loaded`;
          if(!json.has_more) break;
          page += 1;
        }
        document.getElementById('loading').textContent = '';
        render();
      }catch(e){
        document.getElementById('count').textContent = 'Load failed: ' + e;
        document.getElementById('loading').textContent = '';
      }
    }

    function updateSortedHeader(){
      try{
        document.querySelectorAll('th[data-sort]').forEach(th=>{
          if(th.getAttribute('data-sort') === currentSort) th.classList.add('sorted'); else th.classList.remove('sorted');
        });
        const sortLabel = (currentSortDir === 'random') ? 'Random' : (currentSortDir === 'desc' ? 'Desc' : 'Asc');
        document.getElementById('sortDir').textContent = 'Sort: ' + sortLabel;
      }catch(e){/* ignore */}
    }

    function render(){
      const rawQ = document.getElementById('q').value || '';
      const q = String(rawQ).toLowerCase().trim();
      // Build safe search term variants. If the query starts with an "r" (or "/r"),
      // search for both forms (with and without a leading slash) so subreddits
      // that include the prefix are matched. We avoid constructing regexes from
      // user input to prevent any injection risks; all comparisons use plain strings.
      const searchTerms = [q];
      // Handle queries that reference subreddits in several shorthand forms:
      // - "/r/name" or "r/name"
      // - "rgrool" (leading 'r' immediately followed by name)
      // Normalize these to bare name + prefixed variants so display_name_prefixed
      // (which may include "/r/" or "r/") is matched.
      let stripped = null;
      const m1 = q.match(/^\/?r\/(.+)$/); // matches /r/name or r/name
      const m2 = q.match(/^r([A-Za-z0-9_]{1,21})$/); // matches rname (e.g., rgrool)
      if (m1 && m1[1]) stripped = m1[1];
      else if (m2 && m2[1]) stripped = m2[1];
      if (stripped) {
        const variants = [stripped, 'r/' + stripped, '/r/' + stripped];
        variants.forEach(v => { if(v && !searchTerms.includes(v)) searchTerms.push(v); });
      }
      const minMraw = (document.getElementById('minMentions') && document.getElementById('minMentions').value) || '';
      const minM = Number(minMraw || 0);
      const maxValRaw = (document.getElementById('maxMentions') && document.getElementById('maxMentions').value) || '';
      const maxM = (maxValRaw === '') ? Infinity : Number(maxValRaw);
      const minSubsRaw = (document.getElementById('minSubscribers') && document.getElementById('minSubscribers').value) || '';
      const minS = (minSubsRaw === '') ? 0 : Number(minSubsRaw);
      const maxSubsRaw = (document.getElementById('maxSubscribers') && document.getElementById('maxSubscribers').value) || '';
      const maxS = (maxSubsRaw === '') ? Infinity : Number(maxSubsRaw);
      const showAvailable = document.getElementById('showAvailable') ? document.getElementById('showAvailable').checked : true;
      const showB = document.getElementById('showBanned').checked;
      const showNSFW = document.getElementById('showNSFW') ? document.getElementById('showNSFW').checked : true;
      const showNonNSFW = document.getElementById('showNonNSFW') ? document.getElementById('showNonNSFW').checked : false;
      const sort = currentSort;
      let list = data.slice();
      if(q){
        list = list.filter(s => {
          const name = (s.name||'').toLowerCase();
          const display = (s.display_name_prefixed||'').toLowerCase();
          // strip common 'r/' or '/r/' prefixes for matching
          const displayNoPrefix = display.replace(/^\/?r\//, '');
          const desc = (s.description||'').toLowerCase();
          const title = (s.title||'').toLowerCase();
          return searchTerms.some(t => name.includes(t) || display.includes(t) || displayNoPrefix.includes(t) || desc.includes(t) || title.includes(t));
        });
      }
      // availability filter logic (independent toggles):
      // - If either checkbox is checked, include only matching groups.
      // - If neither is checked, include all subreddits.
      if(showAvailable || showB){
        list = list.filter(s => (showAvailable && !s.is_banned) || (showB && s.is_banned));
      }
      // NSFW filtering using two independent toggles:
      // - If either is checked, include only matching groups.
      // - If neither is checked, include all.
      if(showNSFW || showNonNSFW){
        list = list.filter(s => (showNSFW && (s.over18 !== false)) || (showNonNSFW && s.over18 === false));
      }
      list = list.filter(s => (s.mentions||0) >= minM);
      if(Number.isFinite(maxM)){
        list = list.filter(s => (s.mentions||0) <= maxM);
      }
      // subscribers filters
      list = list.filter(s => (s.subscribers||0) >= minS);
      if(Number.isFinite(maxS)){
        list = list.filter(s => (s.subscribers||0) <= maxS);
      }

      if(currentSortDir === 'random'){
        for (let i = list.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [list[i], list[j]] = [list[j], list[i]];
        }
      } else {
        list.sort((a,b)=>{
          const key = sort;
          const va = (a[key]===null||a[key]===undefined)?0:a[key];
          const vb = (b[key]===null||b[key]===undefined)?0:b[key];
          if(typeof va === 'string' || typeof vb === 'string'){
            const sa = String(va).toLowerCase();
            const sb = String(vb).toLowerCase();
            if(sa < sb) return currentSortDir === 'desc' ? 1 : -1;
            if(sa > sb) return currentSortDir === 'desc' ? -1 : 1;
            return 0;
          }
          return currentSortDir === 'desc' ? (vb - va) : (va - vb);
        });
      }

      const tbody = document.querySelector('#tbl tbody');
      tbody.innerHTML = '';
      for(const s of list){
        const tr = document.createElement('tr');
        const nameTd = document.createElement('td');
        nameTd.classList.add('col-name');
        const a = document.createElement('a');
        const listing = (document.getElementById('listing') && document.getElementById('listing').value) || 'hot';
        a.href = `https://www.reddit.com/r/${encodeURIComponent(s.name)}/${listing}`;
        a.dataset.name = s.name;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        if(s.is_banned){
          // show struck-through subreddit name, but append (Banned) unstruck
          const nameSpan = document.createElement('span');
          nameSpan.textContent = s.display_name_prefixed || ('/r/' + s.name);
          nameSpan.classList.add('banned');
          a.appendChild(nameSpan);
          const banSpan = document.createElement('span');
          banSpan.textContent = ' (Banned)';
          banSpan.className = 'muted';
          a.appendChild(banSpan);
        } else if(s.not_found){
          // mark not found with dark gray italic and append (Not found)
          a.classList.add('not-found');
          const nf = document.createElement('span');
          nf.textContent = s.display_name_prefixed || ('/r/' + s.name);
          a.appendChild(nf);
          const nfSpan = document.createElement('span');
          nfSpan.textContent = ' (Not found)';
          nfSpan.className = 'muted';
          a.appendChild(nfSpan);
        } else {
          a.textContent = s.display_name_prefixed || ('/r/' + s.name);
        }
        nameTd.appendChild(a);
        tr.appendChild(nameTd);

        const titleTd = document.createElement('td');
        titleTd.classList.add('col-title');
        const isUnprocessed = (s.title === null || s.title === undefined) && !s.is_banned;
        if (isUnprocessed) {
          const sp = document.createElement('span'); sp.className = 'muted'; sp.textContent = 'Pending update';
          titleTd.appendChild(sp);
        } else {
          const rawTitle = (s.title === null || s.title === undefined) ? '' : (s.title || '—');
          titleTd.textContent = rawTitle === '' ? '' : decodeHtmlEntities(rawTitle);
        }
        tr.appendChild(titleTd);
        const mk = (v)=> v===null||v===undefined? '—': v.toString();
        const mentionsTd = document.createElement('td');
        mentionsTd.classList.add('col-mentions');
        if (isUnprocessed) {
          // hide zero mentions for unprocessed subreddits
          if (s.mentions && Number(s.mentions) > 0) {
            mentionsTd.textContent = String(s.mentions);
          } else {
            mentionsTd.textContent = '';
          }
        } else {
          if (s.mentions === null || s.mentions === undefined) {
            mentionsTd.textContent = '';
          } else {
            mentionsTd.textContent = String(s.mentions);
          }
        }
        tr.appendChild(mentionsTd);
        const subsTd = document.createElement('td');
        subsTd.classList.add('col-subscribers');
        if (isUnprocessed) {
          const sp = document.createElement('span'); sp.className = 'muted'; sp.textContent = 'N/A';
          subsTd.appendChild(sp);
        } else {
          if (s.subscribers === null || s.subscribers === undefined) {
            subsTd.textContent = '';
          } else {
            subsTd.textContent = String(s.subscribers);
          }
        }
        tr.appendChild(subsTd);
        const firstTd = document.createElement('td');
        firstTd.classList.add('col-first_mentioned','muted');
        if (s.first_mentioned) {
          firstTd.textContent = new Date(s.first_mentioned*1000).toLocaleDateString();
        } else {
          firstTd.textContent = '';
        }
        tr.appendChild(firstTd);
        const descTd = document.createElement('td'); descTd.classList.add('col-description','muted');
        const descText = (s.description||'')
        if(isUnprocessed){
          descTd.textContent = '—';
        } else if(descText.length > 32){
          const btn = document.createElement('button');
          btn.className = 'btn btn-ghost';
          btn.textContent = descText.slice(0,32) + '...';
          btn.addEventListener('click', ()=>{
            openDescriptionModal(s.public_description_html || s.description || '');
          });
          descTd.appendChild(btn);
        }else{
          descTd.textContent = descText || '—';
        }
        tr.appendChild(descTd);
        tbody.appendChild(tr);
      }
      document.getElementById('count').textContent = `${totalCount} in database (${data.length} loaded) — ${list.length} shown`;
      // update header count as well
      const hc = document.getElementById('headerSubCount');
      if(hc) hc.textContent = `- ${totalCount} Unique subreddits scanned`;
      updateColumnVisibility(list);
    }

    // Periodically refresh the total subreddit count without reloading the page.
    async function refreshTotalCount(){
      try{
        const res = await fetch(`/subreddits?page=1&per_page=1`);
        if(!res.ok) return;
        const json = await res.json();
        const newTotal = json.total || 0;
        if(newTotal !== totalCount){
          totalCount = newTotal;
        }
        const shown = document.querySelectorAll('#tbl tbody tr').length;
        document.getElementById('count').textContent = `${totalCount} in database (${data.length} loaded) — ${shown} shown`;
        const hc = document.getElementById('headerSubCount');
        if(hc) hc.textContent = `- ${totalCount} Unique subreddits scanned`;
      }catch(e){ /* ignore errors */ }
    }

    // refresh every 10 seconds
    setInterval(refreshTotalCount, 10000);

    const qEl = document.getElementById('q');
    const clearQueryBtn = document.getElementById('clearQuery');
    if(qEl){
      qEl.addEventListener('input', (e)=>{
        try{ clearQueryBtn.style.display = (qEl.value && qEl.value.length>0) ? 'inline' : 'none'; }catch(e){}
        render();
      });
    }
    if(clearQueryBtn){
      clearQueryBtn.addEventListener('click', ()=>{ qEl.value = ''; clearQueryBtn.style.display = 'none'; render(); });
    }
    // header click sorting: set sort key and toggle direction if same key
    document.querySelectorAll('th[data-sort]').forEach(th => {
      th.style.cursor = 'pointer';
      th.addEventListener('click', ()=>{
        const key = th.getAttribute('data-sort');
        if(!key) return;
        if(currentSort === key){
          currentSortDir = (currentSortDir === 'desc') ? 'asc' : 'desc';
        }else{
          currentSort = key;
          currentSortDir = 'desc';
        }
        updateSortedHeader();
        render();
      });
    });
    document.getElementById('minMentions').addEventListener('input', (e) => {
      const el = e.target;
      const val = Number(el.value || 0);
      if (!Number.isFinite(val) || val < 0) el.value = 0;
      render();
    });
    const maxEl = document.getElementById('maxMentions');
    if(maxEl){
      maxEl.addEventListener('input', (e) => {
        const el = e.target;
        if(el.value === ''){ render(); return; }
        const val = Number(el.value || 0);
        if(!Number.isFinite(val) || val < 1) el.value = 1;
        render();
      });
    }
    // subscriber filters: validate and re-render on input
    const minSubsEl = document.getElementById('minSubscribers');
    if(minSubsEl){
      minSubsEl.addEventListener('input', (e)=>{
        const el = e.target;
        if(el.value === ''){ render(); return; }
        const val = Number(el.value || 0);
        if(!Number.isFinite(val) || val < 0) el.value = 0;
        render();
      });
    }
    const maxSubsEl = document.getElementById('maxSubscribers');
    if(maxSubsEl){
      maxSubsEl.addEventListener('input', (e)=>{
        const el = e.target;
        if(el.value === ''){ render(); return; }
        const val = Number(el.value || 0);
        if(!Number.isFinite(val) || val < 0) el.value = 0;
        render();
      });
    }

    // Filter popout open/close and clear behavior
    const filterBtn = document.getElementById('filterBtn');
    const filterPop = document.getElementById('filterPop');
    if(filterBtn && filterPop){
      filterBtn.addEventListener('click', (ev)=>{ ev.stopPropagation(); filterPop.style.display = (filterPop.style.display === 'block') ? 'none' : 'block'; });
      // close when clicking outside
      document.addEventListener('click', (ev)=>{
        if(filterPop.style.display === 'block' && !filterPop.contains(ev.target) && ev.target !== filterBtn){
          filterPop.style.display = 'none';
        }
      });
      // prevent clicks inside popout from closing
      filterPop.addEventListener('click', (ev)=> ev.stopPropagation());
      const closePop = document.getElementById('closeFilterPop');
      if(closePop) closePop.addEventListener('click', ()=> filterPop.style.display = 'none');
      const clearBtn = document.getElementById('clearFilters');
      if(clearBtn){
        clearBtn.addEventListener('click', ()=>{
          const mm = document.getElementById('minMentions'); if(mm) mm.value = '';
          const mM = document.getElementById('maxMentions'); if(mM) mM.value = '';
          const ms = document.getElementById('minSubscribers'); if(ms) ms.value = '';
          const mS = document.getElementById('maxSubscribers'); if(mS) mS.value = '';
          render();
        });
      }
      // wire show toggles and the popout Show/Hide-all button
      const showAvailableEl = document.getElementById('showAvailable');
      const showBannedEl = document.getElementById('showBanned');
      const showNSFWEl = document.getElementById('showNSFW');
      const showNonNSFWEl = document.getElementById('showNonNSFW');
      const showAllBtn = document.getElementById('showAll');
      function updateShowAllLabel(){
        if(!showAllBtn) return;
        const sa = showAvailableEl ? showAvailableEl.checked : false;
        const sb = showBannedEl ? showBannedEl.checked : false;
        const sn = showNSFWEl ? showNSFWEl.checked : false;
        const snt = showNonNSFWEl ? showNonNSFWEl.checked : false;
        showAllBtn.textContent = (sa && sb && sn && snt) ? 'Hide all' : 'Show all';
      }
      if(showAvailableEl) showAvailableEl.addEventListener('change', (e)=>{ render(); updateShowAllLabel(); });
      if(showBannedEl) showBannedEl.addEventListener('change', (e)=>{ render(); updateShowAllLabel(); });
      if(showNSFWEl) showNSFWEl.addEventListener('change', (e)=>{ render(); updateShowAllLabel(); });
      if(showNonNSFWEl) showNonNSFWEl.addEventListener('change', (e)=>{ render(); updateShowAllLabel(); });
      if(showAllBtn){
        updateShowAllLabel();
        showAllBtn.addEventListener('click', ()=>{
          const sa = showAvailableEl ? showAvailableEl.checked : false;
          const sb = showBannedEl ? showBannedEl.checked : false;
          const sn = showNSFWEl ? showNSFWEl.checked : false;
          const snt = showNonNSFWEl ? showNonNSFWEl.checked : false;
          const allOn = sa && sb && sn && snt;
          const newState = !allOn;
          if(showAvailableEl) showAvailableEl.checked = newState;
          if(showBannedEl) showBannedEl.checked = newState;
          if(showNSFWEl) showNSFWEl.checked = newState;
          if(showNonNSFWEl) showNonNSFWEl.checked = newState;
          updateShowAllLabel();
          render();
        });
      }
    }
    document.getElementById('reload').addEventListener('click', loadAll);
    document.getElementById('sortDir').addEventListener('click', ()=>{
      if(currentSortDir === 'desc') currentSortDir = 'asc';
      else if(currentSortDir === 'asc') currentSortDir = 'random';
      else currentSortDir = 'desc';
      updateSortedHeader();
      render();
    });
    
      document.getElementById('resetFilters').addEventListener('click', ()=>{
      document.getElementById('q').value = '';
      document.getElementById('minMentions').value = '';
      if(document.getElementById('maxMentions')) document.getElementById('maxMentions').value = '';
      if(document.getElementById('showAvailable')) document.getElementById('showAvailable').checked = true;
      document.getElementById('showBanned').checked = false;
      if(document.getElementById('showNSFW')) document.getElementById('showNSFW').checked = true;
      if(document.getElementById('showNonNSFW')) document.getElementById('showNonNSFW').checked = false;
      document.getElementById('listing').value = 'hot';
      currentSort = 'mentions';
      currentSortDir = 'desc';
      updateSortedHeader();
      render();
    });

    // when user changes the listing dropdown, update all subreddit links on the page
    document.getElementById('listing').addEventListener('change', ()=>{
      const val = document.getElementById('listing').value;
      document.querySelectorAll('#tbl tbody a[data-name]').forEach(a=>{
        a.href = `https://www.reddit.com/r/${encodeURIComponent(a.dataset.name)}/${val}`;
      });
    });

    // modal for showing long descriptions
    function openDescriptionModal(htmlText){
      let modal = document.getElementById('descModal');
      if(!modal){
        modal = document.createElement('div');
        modal.id = 'descModal';
        modal.style.position = 'fixed';
        modal.style.left = 0;
        modal.style.top = 0;
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.background = 'rgba(0,0,0,0.5)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.zIndex = 9999;
        const inner = document.createElement('div');
        inner.style.background = 'white';
        inner.style.maxWidth = '900px';
        inner.style.padding = '20px';
        inner.style.borderRadius = '10px';
        inner.style.maxHeight = '80%';
        inner.style.overflow = 'auto';
        inner.id = 'descModalInner';
        const closeBtn = document.createElement('button');
        closeBtn.innerHTML = '✕';
        closeBtn.setAttribute('aria-label', 'Close');
        closeBtn.title = 'Close';
        closeBtn.className = 'btn btn-ghost';
        closeBtn.style.float = 'right';
        closeBtn.addEventListener('click', ()=>{ modal.remove(); });
        inner.appendChild(closeBtn);
        const content = document.createElement('div');
        content.id = 'descModalContent';
        content.style.whiteSpace = 'pre-wrap';
        content.style.marginTop = '8px';
        inner.appendChild(content);
        modal.appendChild(inner);
        // close modal when clicking outside the inner content
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });
        document.body.appendChild(modal);
      }
      const content = document.getElementById('descModalContent');
      // escape HTML by using textContent
      content.textContent = htmlText || '';
    }

    // initial load: fetch all pages and render
    updateSortedHeader();
    loadAll();
  </script>
</body>
</html>
