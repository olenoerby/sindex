<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <title>Pineapple Index</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{--bg:#fbfdff;--card:#fff;--muted:#6b7280;--accent:#2563eb}
    *{box-sizing:border-box}
    body{font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);margin:20px;color:#0f172a}
    h1{font-size:1.4rem;margin:0 0 6px 0;display:flex;align-items:baseline;gap:8px}
    .header-count{font-size:0.9rem;color:var(--muted);font-weight:500}
    .container{max-width:1200px;margin:0 auto;padding:0 12px}
    .controls{display:flex;flex-direction:column;gap:8px;align-items:stretch;margin-bottom:12px;position:relative}
    .controls-row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    .controls-row--actions{justify-content:flex-end}
    input,select,button{padding:8px 10px;border:1px solid #e6e6e6;border-radius:10px;background:var(--card)}
    button{cursor:pointer}
    .btn{border:0;padding:8px 12px;border-radius:10px;background:#eef2ff;color:var(--accent);font-weight:600}
    .btn:hover{filter:brightness(.98);box-shadow:0 4px 14px rgba(37,99,235,0.12)}
    .btn-no-bold{font-weight:400;font-size:1rem;line-height:1.2}
    .btn-ghost{background:transparent;border:1px solid #e6e6e6;color:inherit}
    .card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 1px 2px rgba(15,23,42,0.04)}
    table{width:100%;border-collapse:collapse;margin-top:12px}
    th,td{padding:10px;border-bottom:1px solid #f1f5f9;text-align:left}
    th{font-weight:600;color:#0f172a;white-space:nowrap}
    tr:hover{background:#f8fafc}
    .muted{color:var(--muted);font-size:0.9em}
    .badge{background:#eef2ff;color:var(--accent);padding:4px 8px;border-radius:999px;font-size:0.85em}
    .row-actions{display:flex;gap:8px;align-items:center}
    .spinner{width:18px;height:18px;border:3px solid #e6eefc;border-top-color:var(--accent);border-radius:50%;animation:spin 1s linear infinite;display:inline-block}
    @keyframes spin{to{transform:rotate(360deg)}}
    @media (max-width:900px){table{font-size:13px} .controls{gap:6px}}
    @media (max-width:800px){
      .controls{flex-direction:column;align-items:stretch}
      .controls > *{width:100%}
      .controls label{display:flex;justify-content:space-between;align-items:center}
      .header-count{display:none}
    }
    .table-wrap{overflow:auto}
    th.sticky{position:sticky;top:0;background:var(--card);z-index:2}
    .banned{color:#b91c1c;text-decoration:line-through}
    .not-found{color:#6b7280;font-style:italic}
    /* column helper classes */
    .col-name,.col-title,.col-mentions,.col-subscribers,.col-active_users,.col-first_mentioned,.col-last_checked,.col-description{}
    .info-btn{margin-left:6px;min-width:44px;height:28px;border-radius:8px;font-weight:700;font-size:13px;padding:2px 8px;display:inline-flex;align-items:center;justify-content:center;border:1px solid #e6e6e6;background:var(--card);color:var(--muted);cursor:pointer}
    .info-btn:hover{box-shadow:0 2px 8px rgba(0,0,0,0.06)}
  </style>
</head>
<body>
  <h1><a href="/" style="color:inherit;text-decoration:none">Pineapple Index</a><button id="explainBtn" class="info-btn" title="Explanation" aria-label="Explanation">Explanation</button><span id="headerSubCount" class="header-count">0 Unique subreddits scanned</span></h1>
  <p class="muted" style="margin-top:6px">A tribute to <a href="https://www.reddit.com/user/WeirdPineapple" target="_blank" rel="noopener noreferrer">/u/WeirdPineapple</a> — thank you for your contributions!</p>

      <div class="container">
        <div class="controls card">
          <div class="controls-row">
            <div style="position:relative;flex:1;min-width:180px">
              <input id="q" maxlength="200" placeholder="Search name, title or description" style="width:100%;padding-right:34px;box-sizing:border-box" />
              <button id="clearQuery" title="Clear search" style="position:absolute;right:8px;top:50%;transform:translateY(-50%);border:0;background:transparent;cursor:pointer;font-size:14px;display:none;color:var(--muted)">✕</button>
            </div>
            <button id="reload" class="btn btn-ghost btn-no-bold" title="Reload" style="margin-left:8px">↻</button>
          </div>
          <div class="controls-row controls-row--actions">
            <!-- Listing and Sort moved to Options popout -->
            <div style="margin-right:auto" class="muted" id="loading"></div>
            <button id="filterBtn" class="btn btn-ghost" style="margin-left:8px">Filters ▾</button>
            <button id="optionsBtn" class="btn btn-ghost" style="margin-left:8px">Options ▾</button>
            <button id="sortDir" class="btn">Sort: Desc</button>
            <button id="resetFilters" class="btn btn-ghost">Reset</button>
          </div>
        </div>
        <!-- Filter popout: positioned relative to .controls (absolute placement) -->
        <div id="filterPop" style="display:none;position:absolute;z-index:60;min-width:260px;right:12px;top:64px;padding:10px;border-radius:10px;background:var(--card);box-shadow:0 8px 30px rgba(2,6,23,0.08)">
          <div style="display:flex;flex-direction:column;gap:8px">
            <label style="display:flex;justify-content:space-between;align-items:center">Min mentions <input id="minMentions" type="number" placeholder="0" min="0" step="1" style="width:110px"/></label>
            <label style="display:flex;justify-content:space-between;align-items:center">Max mentions <input id="maxMentions" type="number" placeholder="any" min="1" step="1" style="width:110px"/></label>
            <label style="display:flex;justify-content:space-between;align-items:center">Min subscribers <input id="minSubscribers" type="number" placeholder="0" min="0" step="1" style="width:110px"/></label>
            <label style="display:flex;justify-content:space-between;align-items:center">Max subscribers <input id="maxSubscribers" type="number" placeholder="any" min="0" step="1" style="width:110px"/></label>
            <label style="display:flex;justify-content:space-between;align-items:center"><input id="showAvailable" type="checkbox" checked/> Show available</label>
            <label style="display:flex;justify-content:space-between;align-items:center"><input id="showBanned" type="checkbox"/> Show unavailable</label>
            <label style="display:flex;justify-content:space-between;align-items:center"><input id="showNSFW" type="checkbox" checked/> Show NSFW</label>
            <label style="display:flex;justify-content:space-between;align-items:center"><input id="showNonNSFW" type="checkbox"/> Show non-NSFW</label>
            <div style="display:flex;justify-content:space-between;margin-top:6px">
              <button id="clearFilters" class="btn btn-ghost">Clear</button>
              <button id="showAll" class="btn btn-ghost">Show all</button>
              <button id="closeFilterPop" class="btn">Close</button>
            </div>
          </div>
        </div>
        <!-- Options popout for mobile: will hold Sort and Link Opens To when on small screens -->
        <div id="optionsPop" style="display:none;position:absolute;z-index:60;min-width:260px;right:12px;top:64px;padding:10px;border-radius:10px;background:var(--card);box-shadow:0 8px 30px rgba(2,6,23,0.08)">
          <div style="display:flex;flex-direction:column;gap:8px">
            <label style="margin-right:12px;display:flex;justify-content:space-between;align-items:center">Link opens to:
              <select id="listing" style="margin-left:6px">
                <option value="" selected>Default</option>
                <option value="hot">Hot</option>
                <option value="top/?t=all">Top - All time</option>
                <option value="best">Best</option>
                <option value="new">New</option>
                <option value="rising">Rising</option>
              </select>
            </label>
            <label style="margin-right:12px;display:flex;justify-content:space-between;align-items:center">Sort by:
              <select id="sortSelect" style="margin-left:6px">
                <option value="mentions">Mentions</option>
                <option value="subscribers">Subscribers</option>
                <option value="active_users">Active users</option>
                <option value="created_utc">Created</option>
                <option value="first_mentioned">First mentioned</option>
                <option value="display_name_prefixed">Display name</option>
                <option value="title">Title</option>
                <option value="description">Description</option>
                <option value="name">Name</option>
              </select>
            </label>
          </div>
        </div>
      </div>

      <div class="muted" id="count"></div>
      <div id="paginationControls" style="display:flex;gap:8px;align-items:center;margin-top:8px;flex-wrap:wrap"></div>
      <div class="table-wrap card" style="padding:0;margin-top:12px">
      <table id="tbl">
    <thead>
      <tr>
                <th class="sticky col-name" data-sort="display_name_prefixed">Display Name</th>
                <th class="sticky col-title" data-sort="title">Title</th>
                <th class="sticky col-mentions" data-sort="mentions">Mentions</th>
                <th class="sticky col-subscribers" data-sort="subscribers">Subscribers</th>
                <th class="sticky col-first_mentioned" data-sort="first_mentioned">First mentioned</th>
                <th class="sticky col-description" data-sort="description">Description</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  </div>
    </div>
    

  <script>
    let data = [];
    let filteredCount = 0; // number matching current filters (from server)
    let dbTotal = 0; // total number of subreddits in DB
    let currentPage = 1;
    let perPage = (window.innerWidth <= 800) ? 25 : 50; // smaller pages on mobile
    let currentSort = 'mentions';
    let currentSortDir = 'desc'; // 'asc' or 'desc'
    let prefs = {};
    let randomOrder = null; // array of subreddit names preserving a shuffled order

    function setCookie(name, value, days){
      let expires = '';
      if(days){
        const d = new Date(); d.setTime(d.getTime() + (days*24*60*60*1000));
        expires = '; expires=' + d.toUTCString();
      }
      document.cookie = name + '=' + value + expires + '; path=/';
    }
    function getCookie(name){
      const v = document.cookie.match('(^|;)\\s*' + name + '\\s*=\\s*([^;]+)');
      return v ? v.pop() : '';
    }

    function savePrefs(){
      try{
        const p = {
          minMentions: document.getElementById('minMentions') ? document.getElementById('minMentions').value : '',
          maxMentions: document.getElementById('maxMentions') ? document.getElementById('maxMentions').value : '',
          minSubscribers: document.getElementById('minSubscribers') ? document.getElementById('minSubscribers').value : '',
          maxSubscribers: document.getElementById('maxSubscribers') ? document.getElementById('maxSubscribers').value : '',
          showAvailable: document.getElementById('showAvailable') ? !!document.getElementById('showAvailable').checked : false,
          showBanned: document.getElementById('showBanned') ? !!document.getElementById('showBanned').checked : false,
          showNSFW: document.getElementById('showNSFW') ? !!document.getElementById('showNSFW').checked : false,
          showNonNSFW: document.getElementById('showNonNSFW') ? !!document.getElementById('showNonNSFW').checked : false,
          listing: document.getElementById('listing') ? document.getElementById('listing').value : '',
          currentSort, currentSortDir,
          randomOrder: randomOrder || null
        };
        setCookie('pineapple_prefs', encodeURIComponent(JSON.stringify(p)), 365);
      }catch(e){ /* ignore */ }
    }

    function loadPrefs(){
      try{
        const c = getCookie('pineapple_prefs');
        if(!c) return;
        const p = JSON.parse(decodeURIComponent(c));
        prefs = p || {};
        if(document.getElementById('minMentions')) document.getElementById('minMentions').value = prefs.minMentions || '';
        if(document.getElementById('maxMentions')) document.getElementById('maxMentions').value = prefs.maxMentions || '';
        if(document.getElementById('minSubscribers')) document.getElementById('minSubscribers').value = prefs.minSubscribers || '';
        if(document.getElementById('maxSubscribers')) document.getElementById('maxSubscribers').value = prefs.maxSubscribers || '';
        if(document.getElementById('showAvailable')) document.getElementById('showAvailable').checked = !!prefs.showAvailable;
        if(document.getElementById('showBanned')) document.getElementById('showBanned').checked = !!prefs.showBanned;
        if(document.getElementById('showNSFW')) document.getElementById('showNSFW').checked = !!prefs.showNSFW;
        if(document.getElementById('showNonNSFW')) document.getElementById('showNonNSFW').checked = !!prefs.showNonNSFW;
        if(document.getElementById('listing')) document.getElementById('listing').value = prefs.listing || '';
        if(prefs.currentSort) currentSort = prefs.currentSort;
        if(prefs.currentSortDir) currentSortDir = prefs.currentSortDir;
        // reflect saved sort selection in dropdown
        if(document.getElementById('sortSelect')) document.getElementById('sortSelect').value = currentSort;
        if(prefs.randomOrder && Array.isArray(prefs.randomOrder)) randomOrder = prefs.randomOrder;
      }catch(e){ /* ignore malformed cookie */ }
    }

    function generateRandomOrderFromList(list){
      randomOrder = list.map(s=>s.name);
      for (let i = randomOrder.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [randomOrder[i], randomOrder[j]] = [randomOrder[j], randomOrder[i]];
      }
      savePrefs();
    }

    function updateColumnVisibility(list){
      try{
        // Always show columns. Do not hide table columns even if no rows have data
        // for that column; this preserves stable table layout for users.
        const cols = ['title','subscribers','description','first_mentioned','last_checked'];
        cols.forEach(col => {
          document.querySelectorAll('.col-' + col).forEach(el => el.style.display = '');
          const th = document.querySelector('th.col-' + col);
          if(th) th.style.display = '';
        });
      }catch(e){ console.warn('updateColumnVisibility failed', e); }
    }

    // Decode HTML entities in titles so escaped codes like &amp; display as &.
    function decodeHtmlEntities(str){
      if(str === null || str === undefined) return '';
      const d = document.createElement('div');
      // Assign to innerHTML so entities are parsed, then read textContent.
      d.innerHTML = String(str);
      return d.textContent || d.innerText || '';
    }

    // Load a single page from the API (server-side pagination)
    async function loadPage(page = 1){
      document.getElementById('count').textContent = 'Loading...';
      const loadingDiv = document.getElementById('loading');
      loadingDiv.innerHTML = '<span class="spinner" aria-hidden="true"></span>';
      setControlsDisabled(true);
      try{
        const qparams = buildFilterQueryParams();
        const res = await fetch(`/subreddits?page=${page}&per_page=${perPage}&sort=${encodeURIComponent(currentSort)}&sort_dir=${encodeURIComponent(currentSortDir)}${qparams}`);
        if(!res.ok) throw new Error('HTTP '+res.status);
        const json = await res.json();
        data = json.items || [];
        filteredCount = json.total || 0;
        currentPage = page;
        loadingDiv.innerHTML = '';
        render();
        renderPaginationControls();
        setControlsDisabled(false);
      }catch(e){
        document.getElementById('count').textContent = 'Load failed: ' + e;
        loadingDiv.innerHTML = '';
        setControlsDisabled(false);
      }
    }

    function buildFilterQueryParams(){
      try{
        const parts = [];
        const q = (document.getElementById('q') && document.getElementById('q').value) ? String(document.getElementById('q').value).trim() : '';
        if(q) parts.push('q=' + encodeURIComponent(q));
        const mm = document.getElementById('minMentions') ? document.getElementById('minMentions').value : '';
        if(mm) parts.push('min_mentions=' + encodeURIComponent(mm));
        const mM = document.getElementById('maxMentions') ? document.getElementById('maxMentions').value : '';
        if(mM) parts.push('max_mentions=' + encodeURIComponent(mM));
        const ms = document.getElementById('minSubscribers') ? document.getElementById('minSubscribers').value : '';
        if(ms) parts.push('min_subscribers=' + encodeURIComponent(ms));
        const mS = document.getElementById('maxSubscribers') ? document.getElementById('maxSubscribers').value : '';
        if(mS) parts.push('max_subscribers=' + encodeURIComponent(mS));
        const showAvailable = document.getElementById('showAvailable') ? !!document.getElementById('showAvailable').checked : null;
        const showBanned = document.getElementById('showBanned') ? !!document.getElementById('showBanned').checked : null;
        const showNSFW = document.getElementById('showNSFW') ? !!document.getElementById('showNSFW').checked : null;
        const showNonNSFW = document.getElementById('showNonNSFW') ? !!document.getElementById('showNonNSFW').checked : null;
        if(showAvailable !== null) parts.push('show_available=' + (showAvailable ? 'true' : 'false'));
        if(showBanned !== null) parts.push('show_banned=' + (showBanned ? 'true' : 'false'));
        if(showNSFW !== null) parts.push('show_nsfw=' + (showNSFW ? 'true' : 'false'));
        if(showNonNSFW !== null) parts.push('show_non_nsfw=' + (showNonNSFW ? 'true' : 'false'));
        return parts.length ? '&' + parts.join('&') : '';
      }catch(e){ return ''; }
    }

    // Disable/enable interactive controls while a server request is in progress
    function setControlsDisabled(disabled){
      try{
        document.querySelectorAll('#paginationControls button, #paginationControls select, #paginationControls input').forEach(el => el.disabled = disabled);
        const maybe = ['reload','filterBtn','sortDir','resetFilters','listing','sortSelect'];
        maybe.forEach(id => { const el = document.getElementById(id); if(el) el.disabled = disabled; });
      }catch(e){/* ignore */}
    }

    function renderPaginationControls(){
      const ctr = document.getElementById('paginationControls');
      if(!ctr) return;
      ctr.innerHTML = '';
      const totalPages = Math.max(1, Math.ceil((filteredCount || 0) / perPage));
      const prev = document.createElement('button'); prev.className = 'btn btn-ghost'; prev.textContent = '◀ Prev';
      prev.disabled = currentPage <= 1;
      prev.addEventListener('click', ()=>{ if(currentPage>1) loadPage(currentPage-1); });
      const next = document.createElement('button'); next.className = 'btn btn-ghost'; next.textContent = 'Next ▶';
      next.disabled = currentPage >= totalPages;
      next.addEventListener('click', ()=>{ if(currentPage<totalPages) loadPage(currentPage+1); });
      const pageInfo = document.createElement('div'); pageInfo.className = 'muted'; pageInfo.textContent = `Page ${currentPage} / ${totalPages}`;
      const perSel = document.createElement('select'); perSel.style.marginLeft = '8px'; perSel.innerHTML = '<option value="25">25</option><option value="50">50</option><option value="100">100</option>';
      perSel.value = String(perPage);
      perSel.addEventListener('change', ()=>{ perPage = Number(perSel.value); loadPage(1); });
      const goto = document.createElement('input'); goto.type='number'; goto.min=1; goto.style.width='72px'; goto.placeholder='Go to page'; goto.addEventListener('change', ()=>{ const v = Number(goto.value||0); if(v>=1 && v<=totalPages) loadPage(v); });
      ctr.appendChild(prev);
      ctr.appendChild(pageInfo);
      ctr.appendChild(next);
      ctr.appendChild(document.createTextNode(' per page:'));
      ctr.appendChild(perSel);
      ctr.appendChild(goto);
    }

    function updateSortedHeader(){
      try{
        document.querySelectorAll('th[data-sort]').forEach(th=>{
          if(th.getAttribute('data-sort') === currentSort) th.classList.add('sorted'); else th.classList.remove('sorted');
        });
        const sortLabel = (currentSortDir === 'random') ? 'Random' : (currentSortDir === 'desc' ? 'Desc' : 'Asc');
        document.getElementById('sortDir').textContent = 'Sort: ' + sortLabel;
        if(document.getElementById('sortSelect')) document.getElementById('sortSelect').value = currentSort;
      }catch(e){/* ignore */}
    }

    function render(){
      const rawQ = document.getElementById('q').value || '';
      const q = String(rawQ).toLowerCase().trim();
      // Build safe search term variants. If the query starts with an "r" (or "/r"),
      // search for both forms (with and without a leading slash) so subreddits
      // that include the prefix are matched. We avoid constructing regexes from
      // user input to prevent any injection risks; all comparisons use plain strings.
      const searchTerms = [q];
      // Handle queries that reference subreddits in several shorthand forms:
      // - "/r/name" or "r/name"
      // - "rgrool" (leading 'r' immediately followed by name)
      // Normalize these to bare name + prefixed variants so display_name_prefixed
      // (which may include "/r/" or "r/") is matched.
      let stripped = null;
      const m1 = q.match(/^\/?r\/(.+)$/); // matches /r/name or r/name
      const m2 = q.match(/^r([A-Za-z0-9_]{1,21})$/); // matches rname (e.g., rgrool)
      if (m1 && m1[1]) stripped = m1[1];
      else if (m2 && m2[1]) stripped = m2[1];
      if (stripped) {
        const variants = [stripped, 'r/' + stripped, '/r/' + stripped];
        variants.forEach(v => { if(v && !searchTerms.includes(v)) searchTerms.push(v); });
      }
      const minMraw = (document.getElementById('minMentions') && document.getElementById('minMentions').value) || '';
      const minM = Number(minMraw || 0);
      const maxValRaw = (document.getElementById('maxMentions') && document.getElementById('maxMentions').value) || '';
      const maxM = (maxValRaw === '') ? Infinity : Number(maxValRaw);
      const minSubsRaw = (document.getElementById('minSubscribers') && document.getElementById('minSubscribers').value) || '';
      const minS = (minSubsRaw === '') ? 0 : Number(minSubsRaw);
      const maxSubsRaw = (document.getElementById('maxSubscribers') && document.getElementById('maxSubscribers').value) || '';
      const maxS = (maxSubsRaw === '') ? Infinity : Number(maxSubsRaw);
      const showAvailable = document.getElementById('showAvailable') ? document.getElementById('showAvailable').checked : true;
      const showB = document.getElementById('showBanned').checked;
      const showNSFW = document.getElementById('showNSFW') ? document.getElementById('showNSFW').checked : true;
      const showNonNSFW = document.getElementById('showNonNSFW') ? document.getElementById('showNonNSFW').checked : false;
      const sort = currentSort;
      let list = data.slice();
      if(q){
        list = list.filter(s => {
          const name = (s.name||'').toLowerCase();
          const display = (s.display_name_prefixed||'').toLowerCase();
          // strip common 'r/' or '/r/' prefixes for matching
          const displayNoPrefix = display.replace(/^\/?r\//, '');
          const desc = (s.description||'').toLowerCase();
          const title = (s.title||'').toLowerCase();
          return searchTerms.some(t => name.includes(t) || display.includes(t) || displayNoPrefix.includes(t) || desc.includes(t) || title.includes(t));
        });
      }
      // availability filter logic (independent toggles):
      // - If either checkbox is checked, include only matching groups.
      // - If neither is checked, include all subreddits.
      if(showAvailable || showB){
        list = list.filter(s => (showAvailable && !s.is_banned) || (showB && s.is_banned));
      }
      // NSFW filtering using two independent toggles:
      // - If either is checked, include only matching groups.
      // - If neither is checked, include all.
      // Treat NULL/undefined as NSFW; only explicit `false` is non-NSFW.
      if(showNSFW || showNonNSFW){
        list = list.filter(s => (showNSFW && (s.over18 === true || s.over18 == null)) || (showNonNSFW && s.over18 === false));
      }
      list = list.filter(s => (s.mentions||0) >= minM);
      if(Number.isFinite(maxM)){
        list = list.filter(s => (s.mentions||0) <= maxM);
      }
      // subscribers filters
      list = list.filter(s => (s.subscribers||0) >= minS);
      if(Number.isFinite(maxS)){
        list = list.filter(s => (s.subscribers||0) <= maxS);
      }

      // Server provides ordered results based on `sort` and `sort_dir` parameters.
      // Do not re-sort the page client-side; preserve server ordering and only
      // apply client-side filters/search on the returned page of rows.

      const tbody = document.querySelector('#tbl tbody');
      tbody.innerHTML = '';
      for(const s of list){
        const tr = document.createElement('tr');
        const nameTd = document.createElement('td');
        nameTd.classList.add('col-name');
        const a = document.createElement('a');
        const listingEl = document.getElementById('listing');
        const listing = listingEl ? listingEl.value : '';
        if(listing){
          a.href = `https://www.reddit.com/r/${encodeURIComponent(s.name)}/${listing}`;
        } else {
          a.href = `https://www.reddit.com/r/${encodeURIComponent(s.name)}`;
        }
        a.dataset.name = s.name;
        a.target = '_blank';
        a.rel = 'noopener noreferrer';
        if(s.is_banned){
          // show struck-through subreddit name, but append (Banned) unstruck
          const nameSpan = document.createElement('span');
          nameSpan.textContent = s.display_name_prefixed || ('/r/' + s.name);
          nameSpan.classList.add('banned');
          a.appendChild(nameSpan);
          const banSpan = document.createElement('span');
          banSpan.textContent = ' (Banned)';
          banSpan.className = 'muted';
          a.appendChild(banSpan);
        } else if(s.not_found){
          // mark not found with dark gray italic and append (Not found)
          a.classList.add('not-found');
          const nf = document.createElement('span');
          nf.textContent = s.display_name_prefixed || ('/r/' + s.name);
          a.appendChild(nf);
          const nfSpan = document.createElement('span');
          nfSpan.textContent = ' (Not found)';
          nfSpan.className = 'muted';
          a.appendChild(nfSpan);
        } else {
          a.textContent = s.display_name_prefixed || ('/r/' + s.name);
        }
        nameTd.appendChild(a);
        tr.appendChild(nameTd);

        const titleTd = document.createElement('td');
        titleTd.classList.add('col-title');
        const isUnprocessed = (s.title === null || s.title === undefined) && !s.is_banned;
        if (isUnprocessed) {
          const sp = document.createElement('span'); sp.className = 'muted'; sp.textContent = 'Pending update';
          titleTd.appendChild(sp);
        } else {
          const rawTitle = (s.title === null || s.title === undefined) ? '' : (s.title || '—');
          titleTd.textContent = rawTitle === '' ? '' : decodeHtmlEntities(rawTitle);
        }
        tr.appendChild(titleTd);
        const mk = (v)=> v===null||v===undefined? '—': v.toString();
        const mentionsTd = document.createElement('td');
        mentionsTd.classList.add('col-mentions');
        if (isUnprocessed) {
          // hide zero mentions for unprocessed subreddits
          if (s.mentions && Number(s.mentions) > 0) {
            mentionsTd.textContent = String(s.mentions);
          } else {
            mentionsTd.textContent = '';
          }
        } else {
          if (s.mentions === null || s.mentions === undefined) {
            mentionsTd.textContent = '';
          } else {
            mentionsTd.textContent = String(s.mentions);
          }
        }
        tr.appendChild(mentionsTd);
        const subsTd = document.createElement('td');
        subsTd.classList.add('col-subscribers');
        if (isUnprocessed) {
          const sp = document.createElement('span'); sp.className = 'muted'; sp.textContent = 'N/A';
          subsTd.appendChild(sp);
        } else {
          if (s.subscribers === null || s.subscribers === undefined) {
            subsTd.textContent = '';
          } else {
            subsTd.textContent = String(s.subscribers);
          }
        }
        tr.appendChild(subsTd);
        const firstTd = document.createElement('td');
        firstTd.classList.add('col-first_mentioned','muted');
        if (s.first_mentioned) {
          firstTd.textContent = new Date(s.first_mentioned*1000).toLocaleDateString();
        } else {
          firstTd.textContent = '';
        }
        tr.appendChild(firstTd);
        const descTd = document.createElement('td'); descTd.classList.add('col-description','muted');
        const descText = (s.description||'')
        if(isUnprocessed){
          descTd.textContent = '—';
        } else if(descText.length > 32){
          const btn = document.createElement('button');
          btn.className = 'btn btn-ghost';
          btn.textContent = descText.slice(0,32) + '...';
          btn.addEventListener('click', ()=>{
            openDescriptionModal(s.public_description_html || s.description || '');
          });
          descTd.appendChild(btn);
        }else{
          descTd.textContent = descText || '—';
        }
        tr.appendChild(descTd);
        tbody.appendChild(tr);
      }
      document.getElementById('count').textContent = `${filteredCount} filtered out of ${dbTotal} in database`;
      // update header count as well (show overall DB total)
      const hc = document.getElementById('headerSubCount');
      if(hc) hc.textContent = `${dbTotal} subreddits found`;
      updateColumnVisibility(list);
      // Persist current filter/sort/listing preferences so back-navigation preserves state
      try{ savePrefs(); }catch(e){}
    }

    // Periodically refresh the total subreddit count without reloading the page.
    async function refreshTotalCount(){
      try{
        // Get overall DB totals from /stats so we can show "filtered out of X in database"
        const res = await fetch('/stats');
        if(!res.ok) return;
        const json = await res.json();
        const newDbTotal = json.total_subreddits || 0;
        if(newDbTotal !== dbTotal){
          dbTotal = newDbTotal;
        }
        // update displayed counts
        document.getElementById('count').textContent = `${filteredCount} filtered out of ${dbTotal} in database`;
        const hc = document.getElementById('headerSubCount');
        if(hc) hc.textContent = `${dbTotal} subreddits found`;
      }catch(e){ /* ignore errors */ }
    }

    // refresh every 10 seconds and once immediately
    setInterval(refreshTotalCount, 10000);
    refreshTotalCount();

    // debounce utility for input-driven requests
    function debounce(fn, wait){
      let t = null;
      return function(...args){
        if(t) clearTimeout(t);
        t = setTimeout(()=> fn.apply(this, args), wait);
      };
    }

    // Debounced loader used for frequent input changes (typing)
    const debouncedLoadPage = debounce(()=>{ try{ savePrefs(); }catch(e){} loadPage(1); }, 350);

    const qEl = document.getElementById('q');
    const clearQueryBtn = document.getElementById('clearQuery');
    if(qEl){
      qEl.addEventListener('input', (e)=>{
        try{ clearQueryBtn.style.display = (qEl.value && qEl.value.length>0) ? 'inline' : 'none'; }catch(e){}
        debouncedLoadPage();
      });
    }
    if(clearQueryBtn){
      clearQueryBtn.addEventListener('click', ()=>{ qEl.value = ''; clearQueryBtn.style.display = 'none'; try{ savePrefs(); }catch(e){} loadPage(1); });
    }

    // Explanation button: opens modal; move between header and filter popout on resize
    (function(){
      const explainId = 'explainBtn';
      const infoText = 'How data is collected:\n\n- The scanner periodically reads recent Reddit posts and extracts references to subreddits.\n- Mentioned subreddits are recorded when a subreddit URL is named in a post or comment the scanner processes.\n\nWhat is a mention?\n\n- This is the count of distinct subreddits detected in the collected data, attempting to only counting a mention once per user who submitted it.\n\nUpdate frequency:\n\n- The scanner runs on a schedule (configured in deployment). The site reflects the last scanner run.';

      function ensureButton(){
        let btn = document.getElementById(explainId);
        if(!btn){
          btn = document.createElement('button');
          btn.id = explainId;
          btn.className = 'info-btn';
          btn.title = 'Explanation';
          btn.setAttribute('aria-label','Explanation');
          btn.textContent = 'Explanation';
          // default place in header if possible
          const h = document.querySelector('h1');
          if(h) h.insertBefore(btn, document.getElementById('headerSubCount'));
        }
        btn.onclick = ()=> openDescriptionModal(infoText);
        return btn;
      }

      function placeExplainButton(){
        const btn = ensureButton();
        const filterPop = document.getElementById('filterPop');
        // mobile: move into filter popout (menu); desktop: place in header and push right
        if(window.innerWidth <= 800 && filterPop){
          if(filterPop.contains(btn)) return;
          filterPop.insertBefore(btn, filterPop.firstChild);
          btn.style.marginLeft = '';
        } else {
          const h = document.querySelector('h1');
          if(!h) return;
          if(h.contains(btn)){
            // ensure pushed to right
            btn.style.marginLeft = 'auto';
            return;
          }
          h.insertBefore(btn, document.getElementById('headerSubCount'));
          btn.style.marginLeft = 'auto';
        }
      }

      // initial placement and react to resize
      placeExplainButton();
      window.addEventListener('resize', ()=>{ placeExplainButton(); placeOptionsButton(); });
    })();
    // Options popout: move the sort/listing labels into the popout on mobile
    (function(){
      const optionsId = 'optionsBtn';
      const optionsPopId = 'optionsPop';
      function ensureOptionsButton(){
        let btn = document.getElementById(optionsId);
        return btn;
      }

      function placeOptionsButton(){
        // Options button is always visible; controls are authored inside
        // the options popout in the HTML, so no dynamic moving/cloning is required.
        const btn = ensureOptionsButton();
        if(btn) btn.style.display = '';
      }

      // toggle behavior for the options popout
      const optionsBtn = document.getElementById('optionsBtn');
      const optionsPop = document.getElementById('optionsPop');
      if(optionsBtn && optionsPop){
        optionsBtn.addEventListener('click', (ev)=>{
          ev.stopPropagation();
          const newState = (optionsPop.style.display === 'block') ? 'none' : 'block';
          optionsPop.style.display = newState;
          // if opening options, close the filter popout
          if(newState === 'block'){
            const filterPopEl = document.getElementById('filterPop');
            if(filterPopEl) filterPopEl.style.display = 'none';
          }
        });
        document.addEventListener('click', (ev)=>{ if(optionsPop.style.display === 'block' && !optionsPop.contains(ev.target) && ev.target !== optionsBtn) optionsPop.style.display = 'none'; });
        optionsPop.addEventListener('click', (ev)=> ev.stopPropagation());
      }
      // initial placement and resize handler
      placeOptionsButton();
      window.addEventListener('resize', ()=>{ placeOptionsButton(); });
    })();
    // header click sorting: set sort key and toggle direction if same key
    document.querySelectorAll('th[data-sort]').forEach(th => {
      th.style.cursor = 'pointer';
      th.addEventListener('click', ()=>{
        const key = th.getAttribute('data-sort');
        if(!key) return;
        if(currentSort === key){
          currentSortDir = (currentSortDir === 'desc') ? 'asc' : 'desc';
        }else{
          currentSort = key;
          currentSortDir = 'desc';
        }
        updateSortedHeader();
        // Request the current page from the server using the new sort so pagination reflects it
        // Request current page using server-side sorting
        if(document.getElementById('sortSelect')) document.getElementById('sortSelect').value = currentSort;
        savePrefs();
        loadPage(currentPage);
      });
    });
    document.getElementById('minMentions').addEventListener('input', (e) => {
      const el = e.target;
      const val = Number(el.value || 0);
      if (!Number.isFinite(val) || val < 0) el.value = 0;
      debouncedLoadPage();
    });
    const maxEl = document.getElementById('maxMentions');
    if(maxEl){
      maxEl.addEventListener('input', (e) => {
        const el = e.target;
        if(el.value === ''){ debouncedLoadPage(); return; }
        const val = Number(el.value || 0);
        if(!Number.isFinite(val) || val < 1) el.value = 1;
        debouncedLoadPage();
      });
    }
    // subscriber filters: validate and re-render on input
    const minSubsEl = document.getElementById('minSubscribers');
      if(minSubsEl){
      minSubsEl.addEventListener('input', (e)=>{
        const el = e.target;
        if(el.value === ''){ debouncedLoadPage(); return; }
        const val = Number(el.value || 0);
        if(!Number.isFinite(val) || val < 0) el.value = 0;
        debouncedLoadPage();
      });
    }
    const maxSubsEl = document.getElementById('maxSubscribers');
    if(maxSubsEl){
      maxSubsEl.addEventListener('input', (e)=>{
        const el = e.target;
        if(el.value === ''){ debouncedLoadPage(); return; }
        const val = Number(el.value || 0);
        if(!Number.isFinite(val) || val < 0) el.value = 0;
        debouncedLoadPage();
      });
    }

    // Filter popout open/close and clear behavior
    const filterBtn = document.getElementById('filterBtn');
    const filterPop = document.getElementById('filterPop');
    if(filterBtn && filterPop){
      filterBtn.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        const newState = (filterPop.style.display === 'block') ? 'none' : 'block';
        filterPop.style.display = newState;
        // if opening filters, close the options popout
        if(newState === 'block'){
          const optionsPopEl = document.getElementById('optionsPop');
          if(optionsPopEl) optionsPopEl.style.display = 'none';
        }
      });
      // close when clicking outside
      document.addEventListener('click', (ev)=>{
        if(filterPop.style.display === 'block' && !filterPop.contains(ev.target) && ev.target !== filterBtn){
          filterPop.style.display = 'none';
        }
      });
      // prevent clicks inside popout from closing
      filterPop.addEventListener('click', (ev)=> ev.stopPropagation());
      const closePop = document.getElementById('closeFilterPop');
      if(closePop) closePop.addEventListener('click', ()=> filterPop.style.display = 'none');
      const clearBtn = document.getElementById('clearFilters');
      if(clearBtn){
        clearBtn.addEventListener('click', ()=>{
          const mm = document.getElementById('minMentions'); if(mm) mm.value = '';
          const mM = document.getElementById('maxMentions'); if(mM) mM.value = '';
          const ms = document.getElementById('minSubscribers'); if(ms) ms.value = '';
          const mS = document.getElementById('maxSubscribers'); if(mS) mS.value = '';
          try{ savePrefs(); }catch(e){}
          loadPage(1);
        });
      }
      // wire show toggles and the popout Show/Hide-all button
      const showAvailableEl = document.getElementById('showAvailable');
      const showBannedEl = document.getElementById('showBanned');
      const showNSFWEl = document.getElementById('showNSFW');
      const showNonNSFWEl = document.getElementById('showNonNSFW');
      const showAllBtn = document.getElementById('showAll');
      function updateShowAllLabel(){
        if(!showAllBtn) return;
        const sa = showAvailableEl ? showAvailableEl.checked : false;
        const sb = showBannedEl ? showBannedEl.checked : false;
        const sn = showNSFWEl ? showNSFWEl.checked : false;
        const snt = showNonNSFWEl ? showNonNSFWEl.checked : false;
        showAllBtn.textContent = (sa && sb && sn && snt) ? 'Hide all' : 'Show all';
      }
      if(showAvailableEl) showAvailableEl.addEventListener('change', (e)=>{ updateShowAllLabel(); try{ savePrefs(); }catch(err){} loadPage(1); });
      if(showBannedEl) showBannedEl.addEventListener('change', (e)=>{ updateShowAllLabel(); try{ savePrefs(); }catch(err){} loadPage(1); });
      if(showNSFWEl) showNSFWEl.addEventListener('change', (e)=>{ updateShowAllLabel(); try{ savePrefs(); }catch(err){} loadPage(1); });
      if(showNonNSFWEl) showNonNSFWEl.addEventListener('change', (e)=>{ updateShowAllLabel(); try{ savePrefs(); }catch(err){} loadPage(1); });
      if(showAllBtn){
        updateShowAllLabel();
        showAllBtn.addEventListener('click', ()=>{
          const sa = showAvailableEl ? showAvailableEl.checked : false;
          const sb = showBannedEl ? showBannedEl.checked : false;
          const sn = showNSFWEl ? showNSFWEl.checked : false;
          const snt = showNonNSFWEl ? showNonNSFWEl.checked : false;
          const allOn = sa && sb && sn && snt;
          const newState = !allOn;
          if(showAvailableEl) showAvailableEl.checked = newState;
          if(showBannedEl) showBannedEl.checked = newState;
          if(showNSFWEl) showNSFWEl.checked = newState;
          if(showNonNSFWEl) showNonNSFWEl.checked = newState;
          updateShowAllLabel();
          try{ savePrefs(); }catch(e){}
          loadPage(1);
        });
      }
    }
    document.getElementById('reload').addEventListener('click', ()=> loadPage(currentPage));
    document.getElementById('sortDir').addEventListener('click', ()=>{
      if(currentSortDir === 'desc') currentSortDir = 'asc';
      else if(currentSortDir === 'asc') currentSortDir = 'random';
      else currentSortDir = 'desc';
      // Request current page using server-side sorting (server handles random ordering too)
      updateSortedHeader();
      savePrefs();
      loadPage(currentPage);
    });
    
      document.getElementById('resetFilters').addEventListener('click', ()=>{
      document.getElementById('q').value = '';
      document.getElementById('minMentions').value = '';
      if(document.getElementById('maxMentions')) document.getElementById('maxMentions').value = '';
      if(document.getElementById('showAvailable')) document.getElementById('showAvailable').checked = true;
      document.getElementById('showBanned').checked = false;
      if(document.getElementById('showNSFW')) document.getElementById('showNSFW').checked = true;
      if(document.getElementById('showNonNSFW')) document.getElementById('showNonNSFW').checked = false;
      document.getElementById('listing').value = '';
      currentSort = 'mentions';
      currentSortDir = 'desc';
      updateSortedHeader();
      loadPage(1);
    });

    // when user changes the listing dropdown, update all subreddit links on the page
    document.getElementById('listing').addEventListener('change', ()=>{
      const val = document.getElementById('listing').value;
      document.querySelectorAll('#tbl tbody a[data-name]').forEach(a=>{
        if(val){
          a.href = `https://www.reddit.com/r/${encodeURIComponent(a.dataset.name)}/${val}`;
        } else {
          a.href = `https://www.reddit.com/r/${encodeURIComponent(a.dataset.name)}`;
        }
      });
      try{ savePrefs(); }catch(e){}
    });
    // wire sort dropdown to request server-side ordered pages
    const sortSel = document.getElementById('sortSelect');
    if(sortSel){
      sortSel.addEventListener('change', ()=>{
        currentSort = sortSel.value || 'mentions';
        updateSortedHeader();
        savePrefs();
        loadPage(1);
      });
    }

    // modal for showing long descriptions
    function openDescriptionModal(htmlText){
      let modal = document.getElementById('descModal');
      if(!modal){
        modal = document.createElement('div');
        modal.id = 'descModal';
        modal.style.position = 'fixed';
        modal.style.left = 0;
        modal.style.top = 0;
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.background = 'rgba(0,0,0,0.5)';
        modal.style.display = 'flex';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
        modal.style.zIndex = 9999;
        const inner = document.createElement('div');
        inner.style.background = 'white';
        inner.style.maxWidth = '900px';
        inner.style.padding = '20px';
        inner.style.borderRadius = '10px';
        inner.style.maxHeight = '80%';
        inner.style.overflow = 'auto';
        inner.id = 'descModalInner';
        const closeBtn = document.createElement('button');
        closeBtn.innerHTML = '✕';
        closeBtn.setAttribute('aria-label', 'Close');
        closeBtn.title = 'Close';
        closeBtn.className = 'btn btn-ghost';
        closeBtn.style.float = 'right';
        closeBtn.addEventListener('click', ()=>{ modal.remove(); });
        inner.appendChild(closeBtn);
        const content = document.createElement('div');
        content.id = 'descModalContent';
        content.style.whiteSpace = 'pre-wrap';
        content.style.marginTop = '8px';
        inner.appendChild(content);
        modal.appendChild(inner);
        // close modal when clicking outside the inner content
        modal.addEventListener('click', (e) => {
          if (e.target === modal) modal.remove();
        });
        document.body.appendChild(modal);
      }
      const content = document.getElementById('descModalContent');
      // escape HTML by using textContent
      content.textContent = htmlText || '';
    }

    // initial load: restore preferences, then fetch first page and render
    loadPrefs();
    updateSortedHeader();
    loadPage(1);
  </script>
</body>
</html>
