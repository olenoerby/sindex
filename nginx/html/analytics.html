<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Pineapple Index ‚Äî Analytics</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-X5E2L44KYG"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
  
    gtag('config', 'G-X5E2L44KYG');
  </script>
</head>
<body>
  <nav class="main-nav">
    <a href="/" class="nav-link"><span class="nav-icon">üçç</span><span class="nav-text">Browse</span></a>
    <a href="/list" class="nav-link"><span class="nav-icon">üîç</span><span class="nav-text">Advanced</span></a>
    <a href="/discover" class="nav-link"><span class="nav-icon">‚ú®</span><span class="nav-text">Discover</span></a>
    <a href="/analytics" class="nav-link active"><span class="nav-icon">üìà</span><span class="nav-text">Analytics</span></a>
  </nav>
  
  <div class="page" style="padding-top: 32px; padding-bottom: 60px;">
    <header style="margin-bottom: 32px;">
      <h1 style="margin-bottom: 12px;">Analytics Control Room</h1>
      <p class="lead">A wide-angle view of all Reddit mentions we track. Explore volume over time, identify standout subreddits and posts, and keep tabs on scanner health.</p>
      <div class="meta">
        <span class="pill" id="lastScanned">Last DB run: ‚Äî</span>
        <span class="pill" id="lastPolled">Last polled: ‚Äî</span>
        <span class="pill" id="window">Window: 30 days</span>
      </div>
      <div class="controls">
        <span class="muted" style="margin-right: 8px;">Timeline window:</span>
        <button class="btn" data-days="30">30d</button>
        <button class="btn" data-days="90">90d</button>
        <button class="btn" data-days="180">180d</button>
        <button class="btn" data-days="365">1y</button>
        <button class="btn" data-days="999999">All time</button>
      </div>
    </header>

    <section class="grid" id="statGrid">
      <div class="card">
        <h3 id="totalMentionsTitle">Total mentions</h3>
        <div class="stat-value" id="totalMentions">‚Äî</div>
        <div class="stat-sub" id="mentionsPerDay">‚Äî</div>
      </div>
      <div class="card">
        <h3 id="totalSubsTitle">Total subreddits</h3>
        <div class="stat-value" id="totalSubs">‚Äî</div>
        <div class="stat-sub">All tracked subs, including zero-mention.</div>
      </div>
      <div class="card">
        <h3 id="totalPostsTitle">Total posts</h3>
        <div class="stat-value" id="totalPosts">‚Äî</div>
        <div class="stat-sub" id="mentionsPerPost">‚Äî</div>
      </div>
      <div class="card">
        <h3 id="totalCommentsTitle">Total comments</h3>
        <div class="stat-value" id="totalComments">‚Äî</div>
        <div class="stat-sub" id="commentsPerPost">‚Äî</div>
      </div>
      <div class="card">
        <h3>Latest scan</h3>
        <div class="stat-value" id="lastScanNewMentions">‚Äî</div>
        <div class="stat-sub" id="lastScanMeta">‚Äî</div>
      </div>
      <div class="card">
        <h3 id="peakMentionTitle">Peak mention day</h3>
        <div class="stat-value" id="peakDay">‚Äî</div>
        <div class="stat-sub" id="peakValue">‚Äî</div>
      </div>
      <div class="card">
        <h3 id="newSubsTitle">New subs</h3>
        <div class="stat-value" id="newSubs30">‚Äî</div>
        <div class="stat-sub" id="newSubsDesc">First-time mentions.</div>
      </div>
      <div class="card card-wide">
        <h3 id="topCommenterTitle">Top commenter</h3>
        <div class="stat-value" id="topCommenterName">‚Äî</div>
        <div class="stat-sub" id="topCommenterCount">‚Äî</div>
      </div>
    </section>

    <section class="layout">
      <div class="card">
        <div class="row-title">
          <h3 style="margin:0">Volume over time</h3>
          <small id="timelineSummary">‚Äî</small>
        </div>
        <div class="chart-wrap"><canvas id="timelineChart"></canvas></div>
      </div>
      <div class="card">
        <div class="row-title">
          <h3 style="margin:0">New subreddits per day</h3>
          <small id="subsSummary">‚Äî</small>
        </div>
        <div class="chart-wrap" style="height: 320px"><canvas id="subsChart"></canvas></div>
        <p class="muted" style="margin:10px 0 0">Shows first-time appearances of a subreddit in comments.</p>
      </div>
    </section>

    <section class="split">
      <div class="card">
        <div class="row-title"><h3 style="margin:0">Top subreddits</h3><small>By total mentions</small></div>
        <table class="table" id="topSubredditsTable">
          <thead><tr><th>#</th><th>Subreddit</th><th>Mentions</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="card">
        <div class="row-title"><h3 style="margin:0">Top commenters</h3><small>By mentions recorded</small></div>
        <table class="table" id="topCommentersTable">
          <thead><tr><th>#</th><th>User</th><th>Comments</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <section class="split" style="margin-top: 20px;">
      <div class="card">
        <div class="row-title"><h3 style="margin:0">Top posts</h3><small>Most-mentioned posts</small></div>
        <table class="table" id="topPostsTable">
          <thead><tr><th>#</th><th>Post</th><th>Mentions</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="card">
        <div class="row-title"><h3 style="margin:0">Unique reach</h3><small>Posts with widest subreddit spread</small></div>
        <table class="table" id="topUniquePostsTable">
          <thead><tr><th>#</th><th>Post</th><th>Distinct subs</th></tr></thead>
          <tbody></tbody>
        </table>
      </div>
    </section>
  </div>

  <script>
    // Cookie functions for age gate
    function setCookie(name, value, days) {
      const date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      document.cookie = `${name}=${value};expires=${date.toUTCString()};path=/`;
    }

    function getCookie(name) {
      const nameEQ = name + '=';
      const cookies = document.cookie.split(';');
      for (let c of cookies) {
        c = c.trim();
        if (c.indexOf(nameEQ) === 0) return c.substring(nameEQ.length);
      }
      return null;
    }

    // Age gate modal
    function showAgeGate(onConfirm) {
      const overlay = document.createElement('div');
      overlay.className = 'age-modal-overlay';
      const box = document.createElement('div');
      box.className = 'age-modal-box';
      const h = document.createElement('h2');
      h.textContent = 'Age confirmation';
      const p = document.createElement('p');
      p.textContent = 'This page may contain explicit (18+) content. Please confirm that you are of the required age to visit this website.';
      const actions = document.createElement('div');
      actions.className = 'age-modal-actions';
      const confirmBtn = document.createElement('button');
      confirmBtn.className = 'btn';
      confirmBtn.textContent = 'I am 18+';
      const leaveBtn = document.createElement('button');
      leaveBtn.className = 'btn btn-ghost';
      leaveBtn.textContent = 'Leave';
      actions.appendChild(leaveBtn);
      actions.appendChild(confirmBtn);
      box.appendChild(h);
      box.appendChild(p);
      box.appendChild(actions);
      overlay.appendChild(box);
      document.body.appendChild(overlay);
      document.body.style.overflow = 'hidden';

      confirmBtn.addEventListener('click', () => {
        try { setCookie('sindex_age_confirmed', '1', 365); } catch(e) {}
        overlay.remove();
        document.body.style.overflow = '';
        onConfirm();
      });

      leaveBtn.addEventListener('click', () => {
        try { overlay.remove(); } catch(e) {}
        window.location.href = 'about:blank';
      });

      confirmBtn.focus();
    }
    
    // Improved analytics dashboard with richer stats and a wider, legible chart.
    // Select only the date range buttons, not the refresh button
    const buttons = Array.from(document.querySelectorAll('.controls .btn'));
    let currentDays = 30;  // Default to 30 days
    let timelineChart, subsChart;
    const textColor = '#d9e4f5';

    // Cache for change detection
    const cache = {
      stats: {},
      daily: {},
      topBlocks: {}
    };

    const fmt = (n, opts={}) => (n ?? 0).toLocaleString('en-US', {maximumFractionDigits: 1, ...opts});
    const fmtDate = (iso) => iso ? new Date(iso).toLocaleString() : '‚Äî';

    // Cookie functions
    function setCookie(name, value, days=365){
      const date = new Date();
      date.setTime(date.getTime() + days * 24 * 60 * 60 * 1000);
      document.cookie = `${name}=${value};expires=${date.toUTCString()};path=/`;
    }
    // getCookie function already defined above for age gate check

    // Initialize currentDays from cookie or default to 30
    function initializeDateRange(){
      const savedDays = getCookie('sindex_analytics_date_range');
      if(savedDays && !isNaN(savedDays)){
        currentDays = Number(savedDays);
      } else {
        currentDays = 30;
        setCookie('sindex_analytics_date_range', 30, 365);
      }
      
      // Update button states based on currentDays
      buttons.forEach(btn => {
        const btnDays = Number(btn.dataset.days || 90);
        if(btnDays === currentDays){
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // Update window display
      const displayText = currentDays >= 999999 ? 'Window: All time' : `Window: ${currentDays} days`;
      document.getElementById('window').textContent = displayText;
      updateCardTitles();
    }

    // Update card titles to show the selected date range
    function updateCardTitles(){
      const rangeText = currentDays >= 999999 ? 'All time' : `${currentDays}d`;
      document.getElementById('totalMentionsTitle').textContent = `Total mentions (${rangeText})`;
      document.getElementById('totalSubsTitle').textContent = `Total subreddits (${rangeText})`;
      document.getElementById('totalPostsTitle').textContent = `Total posts (${rangeText})`;
      document.getElementById('totalCommentsTitle').textContent = `Total comments (${rangeText})`;
      document.getElementById('peakMentionTitle').textContent = `Peak mention day (${rangeText})`;
      document.getElementById('newSubsTitle').textContent = `New subs (${rangeText})`;
      document.getElementById('newSubsDesc').textContent = `First-time mentions in the last ${currentDays >= 999999 ? 'all days' : currentDays + ' days'}.`;
      document.getElementById('topCommenterTitle').textContent = `Top commenter (${rangeText})`;
    }

    function bindControls(){
      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          const days = Number(btn.dataset.days);
          currentDays = days;
          buttons.forEach(b => b.classList.toggle('active', b === btn));
          const displayText = days >= 999999 ? 'Window: All time' : `Window: ${days} days`;
          document.getElementById('window').textContent = displayText;
          updateCardTitles();
          setCookie('sindex_analytics_date_range', days, 365);
          fetchStats();
          fetchDaily(days);
          fetchTopBlocks();
        });
      });
    }

    async function fetchStats(){
      try {
        const res = await fetch(`/stats?days=${currentDays}`);
        if(!res.ok) throw new Error('HTTP '+res.status);
        const s = await res.json();
        
        // Only update if values changed
        if(cache.stats.total_mentions !== s.total_mentions) {
          document.getElementById('totalMentions').textContent = fmt(s.total_mentions);
          cache.stats.total_mentions = s.total_mentions;
        }
        if(cache.stats.total_subreddits !== s.total_subreddits) {
          document.getElementById('totalSubs').textContent = fmt(s.total_subreddits);
          cache.stats.total_subreddits = s.total_subreddits;
        }
        if(cache.stats.total_posts !== s.total_posts) {
          document.getElementById('totalPosts').textContent = fmt(s.total_posts);
          cache.stats.total_posts = s.total_posts;
        }
        if(cache.stats.total_comments !== s.total_comments) {
          document.getElementById('totalComments').textContent = fmt(s.total_comments);
          cache.stats.total_comments = s.total_comments;
        }
        if(cache.stats.last_scanned !== s.last_scanned) {
          document.getElementById('lastScanned').textContent = 'Last DB run: ' + fmtDate(s.last_scanned);
          cache.stats.last_scanned = s.last_scanned;
        }
        if(cache.stats.last_scan_new_mentions !== s.last_scan_new_mentions) {
          document.getElementById('lastScanNewMentions').textContent = fmt(s.last_scan_new_mentions ?? 0) + ' new mentions';
          cache.stats.last_scan_new_mentions = s.last_scan_new_mentions;
        }
        const dur = s.last_scan_duration ? `${fmt(s.last_scan_duration, {maximumFractionDigits:0})}s` : '‚Äî';
        const started = s.last_scan_started ? new Date(s.last_scan_started).toLocaleString() : '‚Äî';
        const meta = `Started ${started} ¬∑ Duration ${dur}`;
        if(cache.stats.lastScanMeta !== meta) {
          document.getElementById('lastScanMeta').textContent = meta;
          cache.stats.lastScanMeta = meta;
        }
        document.getElementById('lastPolled').textContent = 'Last polled: ' + new Date().toLocaleString();
      } catch(err) {
        console.warn('stats failed', err);
      }
    }

    function ensureCharts(){
      if(!timelineChart){
        const ctx = document.getElementById('timelineChart').getContext('2d');
        timelineChart = new Chart(ctx, {
          type: 'line',
          data: { labels: [], datasets: [
            { label: 'Mentions', data: [], borderColor: '#1ec6b3', backgroundColor: 'rgba(30,198,179,0.12)', tension: 0.4, fill: true },
            { label: 'Posts', data: [], borderColor: '#7dd3fc', backgroundColor: 'rgba(125,211,252,0.1)', tension: 0.4, fill: true },
            { label: 'Comments', data: [], borderColor: '#f97316', backgroundColor: 'rgba(249,115,22,0.1)', tension: 0.4, fill: true }
          ]},
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { labels: { color: textColor } } },
            scales: {
              x: { ticks: { color: textColor }, grid: { color: 'rgba(255,255,255,0.05)' } },
              y: { ticks: { color: textColor }, grid: { color: 'rgba(255,255,255,0.05)' }, beginAtZero: true }
            }
          }
        });
      }
      if(!subsChart){
        const ctx = document.getElementById('subsChart').getContext('2d');
        subsChart = new Chart(ctx, {
          type: 'bar',
          data: { labels: [], datasets: [
            { label: 'New subreddits', data: [], backgroundColor: 'rgba(30,198,179,0.5)', borderColor: '#1ec6b3', borderWidth: 1.5 },
            { label: 'Mentions', data: [], backgroundColor: 'rgba(249,115,22,0.35)', borderColor: '#f97316', borderWidth: 1.5 }
          ]},
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: { legend: { labels: { color: textColor } } },
            scales: {
              x: { ticks: { color: textColor }, grid: { display: false }, barPercentage: 0.8, categoryPercentage: 0.9 },
              y: { ticks: { color: textColor }, grid: { color: 'rgba(255,255,255,0.05)' }, beginAtZero: true }
            }
          }
        });
      }
    }

    async function fetchDaily(days){
      ensureCharts();
      try {
        const res = await fetch(`/stats/daily?days=${days}`);
        if(!res.ok) throw new Error('HTTP '+res.status);
        const { items=[] } = await res.json();

        // Respect the requested window client-side in case the server returns a larger set
        const visibleItems = (days >= 999999) ? items : items.slice(-Math.max(0, Number(days)));

        // Create a hash of the visible data to detect changes
        const dataKey = JSON.stringify(visibleItems);
        if(cache.daily[days] === dataKey) {
          return; // No changes, skip update
        }
        cache.daily[days] = dataKey;

        const labels = visibleItems.map(it => it.date);
        const mentions = visibleItems.map(it => it.mentions || 0);
        const posts = visibleItems.map(it => it.posts || 0);
        const comments = visibleItems.map(it => it.comments || 0);
        const newSubs = visibleItems.map(it => it.new_subreddits || 0);

        // Update timeline chart
        timelineChart.data.labels = labels;
        timelineChart.data.datasets[0].data = mentions;
        timelineChart.data.datasets[1].data = posts;
        timelineChart.data.datasets[2].data = comments;
        timelineChart.update();

        // Update subs chart (smaller set for readability)
        const sampleEvery = Math.max(1, Math.floor(labels.length / 40));
        const slimLabels = labels.filter((_, idx) => idx % sampleEvery === 0);
        const slimSubs = newSubs.filter((_, idx) => idx % sampleEvery === 0);
        const slimMentions = mentions.filter((_, idx) => idx % sampleEvery === 0);
        subsChart.data.labels = slimLabels;
        subsChart.data.datasets[0].data = slimSubs;
        subsChart.data.datasets[1].data = slimMentions;
        subsChart.update();

        const totalMentions = mentions.reduce((a,b) => a+b, 0);
        const totalPosts = posts.reduce((a,b) => a+b, 0);
        const totalComments = comments.reduce((a,b) => a+b, 0);
        const avgMentions = mentions.length ? totalMentions / mentions.length : 0;
        // Show average for last 7 days within the selected (visible) range
        const daysToShow = Math.min(7, mentions.length);
        const last7 = mentions.slice(-daysToShow);
        const avg7 = last7.length ? last7.reduce((a,b)=>a+b,0) / last7.length : 0;
        document.getElementById('mentionsPerDay').textContent = `${fmt(avgMentions)} avg/day ¬∑ ${fmt(avg7)} last ${daysToShow}d`;
        document.getElementById('mentionsPerPost').textContent = totalPosts ? `${fmt(totalMentions / totalPosts)} mentions per post` : '‚Äî';
        document.getElementById('commentsPerPost').textContent = totalPosts ? `${fmt(totalComments / totalPosts)} comments per post` : '‚Äî';

        // Peak day
        let peakIdx = 0; let peakVal = 0;
        mentions.forEach((v, i) => { if(v > peakVal){ peakVal = v; peakIdx = i; } });
        document.getElementById('peakDay').textContent = labels[peakIdx] || '‚Äî';
        document.getElementById('peakValue').textContent = `${fmt(peakVal)} mentions on peak day`;

        // New subs within the selected date range
        // newSubs already reflects the visible window, so sum directly
        const sumNewSubs = newSubs.reduce((a,b)=>a+b,0);
        document.getElementById('newSubs30').textContent = fmt(sumNewSubs);
        
        // Summaries
        const lastLabel = labels[labels.length-1];
        document.getElementById('timelineSummary').textContent = `${fmt(totalMentions)} mentions, ${fmt(totalPosts)} posts, ${fmt(totalComments)} comments across ${labels.length} days`;
        const peakSubs = Math.max(...newSubs, 0);
        document.getElementById('subsSummary').textContent = `${fmt(sumNewSubs)} new subs (${currentDays >= 999999 ? 'all time' : currentDays + 'd'}) ¬∑ peak ${fmt(peakSubs)} in a day`;
      } catch(err) {
        console.warn('daily failed', err);
      }
    }

    async function fetchTopBlocks(){
      try {
        // Top subreddits
        const ts = await fetch(`/stats/top?limit=20&days=${currentDays}`);
        if(ts.ok){
          const data = await ts.json();
          const dataKey = JSON.stringify(data.slice(0,15));
          if(cache.topBlocks.subreddits !== dataKey) {
            cache.topBlocks.subreddits = dataKey;
            const tbody = document.querySelector('#topSubredditsTable tbody');
            tbody.innerHTML = '';
            data.slice(0,15).forEach((row, idx) => {
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>${idx+1}</td><td>/r/${row.name}</td><td>${fmt(row.mentions)}</td>`;
              tbody.appendChild(tr);
            });
          }
        }

        // Top commenters
        const tc = await fetch(`/stats/top_commenters?limit=15&days=${currentDays}`);
        if(tc.ok){
          const data = await tc.json();
          const dataKey = JSON.stringify(data);
          if(cache.topBlocks.commenters !== dataKey) {
            cache.topBlocks.commenters = dataKey;
            const tbody = document.querySelector('#topCommentersTable tbody');
            tbody.innerHTML = '';
            let topName = '‚Äî', topCount = '‚Äî';
            let rowNum = 1;
            (data.items || []).slice(0,15).forEach((row) => {
              if(!row.user_id){ return; }
              const label = row.user_id;
              let userCell = '';
              if(label.toLowerCase() === '[deleted]'){
                userCell = '[deleted]';
              } else {
                const href = `https://www.reddit.com/user/${encodeURIComponent(label)}`;
                userCell = `<a href="${href}" target="_blank">${label}</a>`;
              }
              if(topName === '‚Äî'){ topName = label === '[deleted]' ? '[deleted]' : label; topCount = fmt(row.comments); }
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>${rowNum}</td><td>${userCell}</td><td>${fmt(row.comments)}</td>`;
              tbody.appendChild(tr);
              rowNum++;
            });
            document.getElementById('topCommenterName').textContent = topName;
            document.getElementById('topCommenterCount').textContent = `${topCount} comments logged`;
          }
        }

        // Top posts (by mentions)
        const tp = await fetch(`/stats/top_posts?limit=15&days=${currentDays}`);
        if(tp.ok){
          const data = await tp.json();
          const dataKey = JSON.stringify(data);
          if(cache.topBlocks.posts !== dataKey) {
            cache.topBlocks.posts = dataKey;
            const tbody = document.querySelector('#topPostsTable tbody');
            tbody.innerHTML = '';
            (data.items || []).slice(0,15).forEach((row, idx) => {
              const title = (row.title || row.reddit_post_id || '').slice(0,120) || '(untitled)';
              const url = `https://www.reddit.com/comments/${encodeURIComponent(row.reddit_post_id)}`;
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>${idx+1}</td><td><a href="${url}" target="_blank">${title}</a></td><td>${fmt(row.mentions)}</td>`;
              tbody.appendChild(tr);
            });
          }
        }

        // Top posts by distinct subreddits
        const tu = await fetch(`/stats/top_unique_posts?limit=15&days=${currentDays}`);
        if(tu.ok){
          const data = await tu.json();
          const dataKey = JSON.stringify(data);
          if(cache.topBlocks.uniquePosts !== dataKey) {
            cache.topBlocks.uniquePosts = dataKey;
            const tbody = document.querySelector('#topUniquePostsTable tbody');
            tbody.innerHTML = '';
            (data.items || []).slice(0,15).forEach((row, idx) => {
              const title = (row.title || row.reddit_post_id || '').slice(0,120) || '(untitled)';
              const url = `https://www.reddit.com/comments/${encodeURIComponent(row.reddit_post_id)}`;
              const tr = document.createElement('tr');
              tr.innerHTML = `<td>${idx+1}</td><td><a href="${url}" target="_blank">${title}</a></td><td>${fmt(row.unique_subreddits)}</td>`;
              tbody.appendChild(tr);
            });
          }
        }
      } catch(err) {
        console.warn('top blocks failed', err);
      }
    }

    bindControls();
    initializeDateRange();
    
    // Check age confirmation and initialize
    function initWithAgeGate() {
      try {
        const confirmed = getCookie('sindex_age_confirmed');
        if (confirmed === '1') {
          // Initial load
          fetchStats();
          fetchDaily(currentDays);
          fetchTopBlocks();
          
          // Auto-refresh every 30 seconds
          setInterval(() => { 
            fetchStats();
            fetchDaily(currentDays);
            fetchTopBlocks();
          }, 30000);
          return;
        }
      } catch(e) { /* ignore and show gate */ }
      
      showAgeGate(() => {
        // Initial load
        fetchStats();
        fetchDaily(currentDays);
        fetchTopBlocks();
        
        // Auto-refresh every 30 seconds
        setInterval(() => { 
          fetchStats();
          fetchDaily(currentDays);
          fetchTopBlocks();
        }, 30000);
      });
    }

    initWithAgeGate();
  </script>
</body>
</html>
